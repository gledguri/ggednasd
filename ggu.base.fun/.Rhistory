list_of_query_print$mismatch <- function_col(list_of_query_print$mismatch)
list_of_query_print$pident <- function_col(list_of_query_print$pident)
cat("\n");questions(paste0("The query \"",i, "\" blast resutls ::"));cat("\n")
print(list_of_query_print[,c(1:2,5,7:13)]);cat("\n")
#Create a summary list
summary_of_list <- list_of_query%>% group_by(Ssciname) %>% summarize(pident_max=max(pident), pident=mean(pident)) #Summary of the dataframe
summary_of_list <- summary_of_list[order(summary_of_list$pident_max,decreasing = T),] #Order the summary based on the %match
chsl <- c(paste0(summary_of_list$Ssciname),"Undefined","Enter manually") #Create taxa selection options
match_id <- 100
l <- summary_of_list$pident_max==match_id
l <- summary_of_list$pident_max==max(summary_of_list$pident_max)
match_id <- max(summary_of_list$pident_max)
match_id <- 100
l <- summary_of_list$pident_max==match_id
sum(l)==0
sum(l)==1
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,30),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm selected ::")
cat("\n");cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname[l],30),summary_of_list$pident_max[l]),"::",
magic.pident(pr_df(summary_of_list$pident_max[l],5),summary_of_list$pident_max[l]),
magic.pident(pr_df(summary_of_list$pident[l],5),summary_of_list$pident[l]))),sep="\n")
paste(summary_of_list$Ssciname[l])
paste(round(summary_of_list$pident_max[summary_of_list$Ssciname%in%summary_of_list$Ssciname[l]]/100,3),collapse=" | ") #Assigns the selected taxa to the input database
j=2
pb <- txtProgressBar(1,length(unique(input$qseqid)),style = 3) #progress bar
i <- unique(input$qseqid)[j] #select the unique query ID
list_of_query <- input[input$qseqid==i,] #Create a dataframe with all subjects the query blasted towards
list_of_query_print <- tibble::tibble(list_of_query);
list_of_query_print$pident <- magic.pident(list_of_query$pident,list_of_query$pident);
list_of_query_print$mismatch <- magic.pident(list_of_query$mismatch,list_of_query$pident)
list_of_query_print$mismatch <- function_col(list_of_query_print$mismatch)
list_of_query_print$pident <- function_col(list_of_query_print$pident)
cat("\n");questions(paste0("The query \"",i, "\" blast resutls ::"));cat("\n")
print(list_of_query_print[,c(1:2,5,7:13)]);cat("\n")
#Create a summary list
summary_of_list <- list_of_query%>% group_by(Ssciname) %>% summarize(pident_max=max(pident), pident=mean(pident)) #Summary of the dataframe
summary_of_list <- summary_of_list[order(summary_of_list$pident_max,decreasing = T),] #Order the summary based on the %match
chsl <- c(paste0(summary_of_list$Ssciname),"Undefined","Enter manually") #Create taxa selection options
match_id <- 100
l <- summary_of_list$pident_max==match_id
sum(l)==1
multiple_sbj <- unlist_uneven_list(strsplit(str_trim(unlist(strsplit(summary_of_list$Ssciname[l], "[|]"))), "[ ]+"))
colnames(multiple_sbj) <- c("genus","species",rep("sub.sp",ncol(multiple_sbj)-2))
colnames
multiple_sbj
multiple_sbj <- unlist_uneven_list(strsplit(str_trim(unlist(strsplit(summary_of_list$Ssciname[l], "[|]"))), "[ ]+"))
colnames(multiple_sbj) <- c("genus","species",rep("sub.sp",ncol(multiple_sbj)-2))
multiple_sbj
unlist_uneven_list(strsplit(str_trim(unlist(strsplit(summary_of_list$Ssciname[l], "[|]"))), "[ ]+"))
multiple_sbj <- unlist_uneven_list(strsplit(str_trim(unlist(strsplit(summary_of_list$Ssciname[l], "[|]"))), "[ ]+"))
colnames(multiple_sbj) <- c("genus","species",rep("sub.sp",ncol(multiple_sbj)-2))
multiple_sbj
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,30),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm suggests to annotate to genus rank ::");cat("\n")
cat(c(paste(magic.pident(pr_df(paste0(unique(multiple_sbj$genus)," spp."),30),mean(summary_of_list$pident_max[l])),"::",
magic.pident(pr_df(mean(summary_of_list$pident_max[l]),5),mean(summary_of_list$pident_max[l])),
magic.pident(pr_df(mean(summary_of_list$pident[l]),5),mean(summary_of_list$pident[l])))),sep = "\n")
paste0(paste(unique(multiple_sbj$genus))," spp.",collapse = " | ")
sl_0 <- paste0(paste(unique(multiple_sbj$genus))," spp.",collapse = " | ")
paste(sl_0," || ", paste(chsl[grep(strsplit(sl_0," ")[[1]][1],chsl)],collapse = " | "))
sl <- paste(sl_0," || ", paste(chsl[grep(strsplit(sl_0," ")[[1]][1],chsl)],collapse = " | "))
sl
paste(round((summary_of_list$pident_max[summary_of_list$Ssciname%in%chsl[grep(strsplit(sl_0," ")[[1]][1],chsl)]]/100),3),collapse = " | ")
multiple_sbj <- unlist_uneven_list(strsplit(str_trim(unlist(strsplit(summary_of_list$Ssciname[l], "[|]"))), "[ ]+"))
colnames(multiple_sbj) <- c("genus","species",rep("sub.sp",ncol(multiple_sbj)-2))
multiple_sbj <- multiple_sbj[!duplicated(paste(multiple_sbj$genus,multiple_sbj$species)),]
multiple_sbj <- multiple_sbj[,1:2]
multiple_sbj$comb_name <- rowpaste(multiple_sbj)
multiple_sbj$pident_max <- NA
multiple_sbj
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,30),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm suggests to annotate to genus rank ::");cat("\n")
cat(c(paste(magic.pident(pr_df(paste0(unique(multiple_sbj$genus)," spp."),30),mean(summary_of_list$pident_max[l])),"::",
magic.pident(pr_df(mean(summary_of_list$pident_max[l]),5),mean(summary_of_list$pident_max[l])),
magic.pident(pr_df(mean(summary_of_list$pident[l]),5),mean(summary_of_list$pident[l])))),sep = "\n")
paste0(paste(unique(multiple_sbj$genus))," spp.",collapse = " | ")
sl_0 <- paste0(paste(unique(multiple_sbj$genus))," spp.",collapse = " | ")
paste(sl_0," || ", paste(chsl[grep(strsplit(sl_0," ")[[1]][1],chsl)],collapse = " | "))
paste(round((summary_of_list$pident_max[summary_of_list$Ssciname%in%chsl[grep(strsplit(sl_0," ")[[1]][1],chsl)]]/100),3),collapse = " | ")
chsl
sl
paste(round((summary_of_list$pident_max[summary_of_list$Ssciname%in%chsl[grep(strsplit(sl_0," ")[[1]][1],chsl)]]/100),3),collapse = " | ")
source("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Data/Rscripts/Manually_annotate.R") #Curate the metadata
manually_annotate(stoeckle_blast_output,method = 2)
manually_annotate(stoeckle_blast_output,method = 2)
setNames(data.frame(matrix(NA,length(unique(input$qseqid)),3)),c("qseqid","ssciname","pident"))
ret_df <- setNames(data.frame(matrix(NA,length(unique(input$qseqid)),3)),c("qseqid","ssciname","pident"))
ret_df$qseqid <- c(unique(input$qseqid))
unique(input$qseqid)[199]
unique(input$annotated_tax[input$qseqid==ii])
input$qseqid==ii
sum(input$qseqid==ii)
ii
ii <- unique(input$qseqid)[2]
ii <- unique(input$qseqid)[199]
unique(input$annotated_tax[input$qseqid==ii])
sum(input$qseqid==ii)
input$annotated_tax[input$qseqid==ii]
ii <- unique(input$qseqid)[9]
input$annotated_tax[input$qseqid==ii]
#Manually | Automatically annotating
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Data/Stockele data/")
source("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Data/Rscripts/Manually_annotate.R") #Curate the metadata
manually_annotate(stoeckle_blast_output,method = 3)
j=1 #build the loop
while (j <= length(unique(input$qseqid))){ #Loop of method 3
pb <- txtProgressBar(1,length(unique(input$qseqid)),style = 3) #progress bar
i <- unique(input$qseqid)[j] #select the unique query ID
list_of_query <- input[input$qseqid==i,] #Create a dataframe with all subjects the query blasted towards
#Esthetics of the list
if (sum(skip==T&!is.na(list_of_query$annotated_tax))>0) {setTxtProgressBar(pb,j);cat("\n");j <- j+1} #Skipping in method 2
else { #Not skipping method 3
list_of_query_print <- tibble::tibble(list_of_query);
list_of_query_print$pident <- magic.pident(list_of_query$pident,list_of_query$pident);
list_of_query_print$mismatch <- magic.pident(list_of_query$mismatch,list_of_query$pident)
list_of_query_print$mismatch <- function_col(list_of_query_print$mismatch)
list_of_query_print$pident <- function_col(list_of_query_print$pident)
#Print
if (print_blast==T) {
cat("\n");questions(paste0("The query \"",i, "\" blast resutls ::"));cat("\n")
print(list_of_query_print[,c(1:2,5,7:13)]);cat("\n")
}
#Create a summary list
summary_of_list <- list_of_query%>% group_by(Ssciname) %>% summarize(pident_max=max(pident), pident=mean(pident)) #Summary of the dataframe
summary_of_list <- summary_of_list[order(summary_of_list$pident_max,decreasing = T),] #Order the summary based on the %match
chsl <- summary_of_list$Ssciname
match_id <- 100
l <- summary_of_list$pident_max==match_id
if (sum(l)==0) {
l <- summary_of_list$pident_max==max(summary_of_list$pident_max)
match_id <- max(summary_of_list$pident_max)
}
if (sum(l)==1) {#If only 1 subject is 100%
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,30),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm selected ::")
cat("\n");cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname[l],30),summary_of_list$pident_max[l]),"::",
magic.pident(pr_df(summary_of_list$pident_max[l],5),summary_of_list$pident_max[l]),
magic.pident(pr_df(summary_of_list$pident[l],5),summary_of_list$pident[l]))),sep="\n")
input$annotated_tax[input$qseqid==i] <- paste(summary_of_list$Ssciname[l])
input$pmatchsel[input$qseqid==i] <- paste(round(summary_of_list$pident_max[summary_of_list$Ssciname%in%summary_of_list$Ssciname[l]]/100,3),collapse=" | ") #Assigns the selected taxa to the input database
}#If only 1 subject is 100%
else{#If multiple subjects are 100%
multiple_sbj <- unlist_uneven_list(strsplit(str_trim(unlist(strsplit(summary_of_list$Ssciname[l], "[|]"))), "[ ]+"))
colnames(multiple_sbj) <- c("genus","species",rep("sub.sp",ncol(multiple_sbj)-2))
multiple_sbj <- multiple_sbj[!duplicated(paste(multiple_sbj$genus,multiple_sbj$species)),]
multiple_sbj <- multiple_sbj[,1:2]
multiple_sbj$comb_name <- rowpaste(multiple_sbj)
multiple_sbj$pident_max <- NA
if (prod(allduplicates(multiple_sbj$genus))==1) { #If multiple subjects are the same genus
chsl <- multiple_sbj$comb_name
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,30),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm suggests to annotate to genus rank ::");cat("\n")
cat(c(paste(magic.pident(pr_df(paste0(unique(multiple_sbj$genus)," spp."),30),mean(summary_of_list$pident_max[l])),"::",
magic.pident(pr_df(mean(summary_of_list$pident_max[l]),5),mean(summary_of_list$pident_max[l])),
magic.pident(pr_df(mean(summary_of_list$pident[l]),5),mean(summary_of_list$pident[l])))),sep = "\n")
sl_0 <- paste0(paste(unique(multiple_sbj$genus))," spp.",collapse = " | ")
sl <- paste(sl_0," || ", paste(multiple_sbj$comb_name,collapse = " | "))
input$annotated_tax[input$qseqid==i] <- sl
for (ii in length(multiple_sbj$comb_name)) {multiple_sbj$pident_max <- summary_of_list$pident_max[min(grep(multiple_sbj$comb_name[ii],summary_of_list$Ssciname))]}
input$pmatchsel[input$qseqid==i] <- paste(round((multiple_sbj$pident_max/100),3),collapse = " | ")
} #If multiple subjects are the same genus
else if (prod(allduplicates(multiple_sbj$genus))==0) {#If multiple subjects are not the same genus
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,40),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm suggests to annotate to all subjects with 100% match ::");cat("\n")
sl <- paste(unique(paste(multiple_sbj$genus,multiple_sbj$species)),collapse = " | ")
input$annotated_tax[input$qseqid==i] <- sl
input$pmatchsel[input$qseqid==i] <- paste(round((summary_of_list$pident_max[summary_of_list$Ssciname%in%str_trim(unlist(strsplit(sl, "[|]")))]/100),3),collapse = " | ")
}#If multiple subjects are not the same genus
}#If multiple subjects are 100%
#Esthetics
setTxtProgressBar(pb,j);cat("\n") #progress bar
j <- j+1 #loop mechanism
write.csv(input,"manually_annotated_function_outcome.csv",row.names = F)
} #Not skipping method 3
} #Loop of method 3
skip=F
j=1 #build the loop
while (j <= length(unique(input$qseqid))){ #Loop of method 3
pb <- txtProgressBar(1,length(unique(input$qseqid)),style = 3) #progress bar
i <- unique(input$qseqid)[j] #select the unique query ID
list_of_query <- input[input$qseqid==i,] #Create a dataframe with all subjects the query blasted towards
#Esthetics of the list
if (sum(skip==T&!is.na(list_of_query$annotated_tax))>0) {setTxtProgressBar(pb,j);cat("\n");j <- j+1} #Skipping in method 2
else { #Not skipping method 3
list_of_query_print <- tibble::tibble(list_of_query);
list_of_query_print$pident <- magic.pident(list_of_query$pident,list_of_query$pident);
list_of_query_print$mismatch <- magic.pident(list_of_query$mismatch,list_of_query$pident)
list_of_query_print$mismatch <- function_col(list_of_query_print$mismatch)
list_of_query_print$pident <- function_col(list_of_query_print$pident)
#Print
if (print_blast==T) {
cat("\n");questions(paste0("The query \"",i, "\" blast resutls ::"));cat("\n")
print(list_of_query_print[,c(1:2,5,7:13)]);cat("\n")
}
#Create a summary list
summary_of_list <- list_of_query%>% group_by(Ssciname) %>% summarize(pident_max=max(pident), pident=mean(pident)) #Summary of the dataframe
summary_of_list <- summary_of_list[order(summary_of_list$pident_max,decreasing = T),] #Order the summary based on the %match
chsl <- summary_of_list$Ssciname
match_id <- 100
l <- summary_of_list$pident_max==match_id
if (sum(l)==0) {
l <- summary_of_list$pident_max==max(summary_of_list$pident_max)
match_id <- max(summary_of_list$pident_max)
}
if (sum(l)==1) {#If only 1 subject is 100%
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,30),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm selected ::")
cat("\n");cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname[l],30),summary_of_list$pident_max[l]),"::",
magic.pident(pr_df(summary_of_list$pident_max[l],5),summary_of_list$pident_max[l]),
magic.pident(pr_df(summary_of_list$pident[l],5),summary_of_list$pident[l]))),sep="\n")
input$annotated_tax[input$qseqid==i] <- paste(summary_of_list$Ssciname[l])
input$pmatchsel[input$qseqid==i] <- paste(round(summary_of_list$pident_max[summary_of_list$Ssciname%in%summary_of_list$Ssciname[l]]/100,3),collapse=" | ") #Assigns the selected taxa to the input database
}#If only 1 subject is 100%
else{#If multiple subjects are 100%
multiple_sbj <- unlist_uneven_list(strsplit(str_trim(unlist(strsplit(summary_of_list$Ssciname[l], "[|]"))), "[ ]+"))
colnames(multiple_sbj) <- c("genus","species",rep("sub.sp",ncol(multiple_sbj)-2))
multiple_sbj <- multiple_sbj[!duplicated(paste(multiple_sbj$genus,multiple_sbj$species)),]
multiple_sbj <- multiple_sbj[,1:2]
multiple_sbj$comb_name <- rowpaste(multiple_sbj)
multiple_sbj$pident_max <- NA
if (prod(allduplicates(multiple_sbj$genus))==1) { #If multiple subjects are the same genus
chsl <- multiple_sbj$comb_name
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,30),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm suggests to annotate to genus rank ::");cat("\n")
cat(c(paste(magic.pident(pr_df(paste0(unique(multiple_sbj$genus)," spp."),30),mean(summary_of_list$pident_max[l])),"::",
magic.pident(pr_df(mean(summary_of_list$pident_max[l]),5),mean(summary_of_list$pident_max[l])),
magic.pident(pr_df(mean(summary_of_list$pident[l]),5),mean(summary_of_list$pident[l])))),sep = "\n")
sl_0 <- paste0(paste(unique(multiple_sbj$genus))," spp.",collapse = " | ")
sl <- paste(sl_0," || ", paste(multiple_sbj$comb_name,collapse = " | "))
input$annotated_tax[input$qseqid==i] <- sl
for (ii in length(multiple_sbj$comb_name)) {multiple_sbj$pident_max <- summary_of_list$pident_max[min(grep(multiple_sbj$comb_name[ii],summary_of_list$Ssciname))]}
input$pmatchsel[input$qseqid==i] <- paste(round((multiple_sbj$pident_max/100),3),collapse = " | ")
} #If multiple subjects are the same genus
else if (prod(allduplicates(multiple_sbj$genus))==0) {#If multiple subjects are not the same genus
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,40),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm suggests to annotate to all subjects with 100% match ::");cat("\n")
sl <- paste(unique(paste(multiple_sbj$genus,multiple_sbj$species)),collapse = " | ")
input$annotated_tax[input$qseqid==i] <- sl
input$pmatchsel[input$qseqid==i] <- paste(round((summary_of_list$pident_max[summary_of_list$Ssciname%in%str_trim(unlist(strsplit(sl, "[|]")))]/100),3),collapse = " | ")
}#If multiple subjects are not the same genus
}#If multiple subjects are 100%
#Esthetics
setTxtProgressBar(pb,j);cat("\n") #progress bar
j <- j+1 #loop mechanism
write.csv(input,"manually_annotated_function_outcome.csv",row.names = F)
} #Not skipping method 3
} #Loop of method 3
print_blas==T
print_blast <- T
j=1 #build the loop
while (j <= length(unique(input$qseqid))){ #Loop of method 3
pb <- txtProgressBar(1,length(unique(input$qseqid)),style = 3) #progress bar
i <- unique(input$qseqid)[j] #select the unique query ID
list_of_query <- input[input$qseqid==i,] #Create a dataframe with all subjects the query blasted towards
#Esthetics of the list
if (sum(skip==T&!is.na(list_of_query$annotated_tax))>0) {setTxtProgressBar(pb,j);cat("\n");j <- j+1} #Skipping in method 2
else { #Not skipping method 3
list_of_query_print <- tibble::tibble(list_of_query);
list_of_query_print$pident <- magic.pident(list_of_query$pident,list_of_query$pident);
list_of_query_print$mismatch <- magic.pident(list_of_query$mismatch,list_of_query$pident)
list_of_query_print$mismatch <- function_col(list_of_query_print$mismatch)
list_of_query_print$pident <- function_col(list_of_query_print$pident)
#Print
if (print_blast==T) {
cat("\n");questions(paste0("The query \"",i, "\" blast resutls ::"));cat("\n")
print(list_of_query_print[,c(1:2,5,7:13)]);cat("\n")
}
#Create a summary list
summary_of_list <- list_of_query%>% group_by(Ssciname) %>% summarize(pident_max=max(pident), pident=mean(pident)) #Summary of the dataframe
summary_of_list <- summary_of_list[order(summary_of_list$pident_max,decreasing = T),] #Order the summary based on the %match
chsl <- summary_of_list$Ssciname
match_id <- 100
l <- summary_of_list$pident_max==match_id
if (sum(l)==0) {
l <- summary_of_list$pident_max==max(summary_of_list$pident_max)
match_id <- max(summary_of_list$pident_max)
}
if (sum(l)==1) {#If only 1 subject is 100%
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,30),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm selected ::")
cat("\n");cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname[l],30),summary_of_list$pident_max[l]),"::",
magic.pident(pr_df(summary_of_list$pident_max[l],5),summary_of_list$pident_max[l]),
magic.pident(pr_df(summary_of_list$pident[l],5),summary_of_list$pident[l]))),sep="\n")
input$annotated_tax[input$qseqid==i] <- paste(summary_of_list$Ssciname[l])
input$pmatchsel[input$qseqid==i] <- paste(round(summary_of_list$pident_max[summary_of_list$Ssciname%in%summary_of_list$Ssciname[l]]/100,3),collapse=" | ") #Assigns the selected taxa to the input database
}#If only 1 subject is 100%
else{#If multiple subjects are 100%
multiple_sbj <- unlist_uneven_list(strsplit(str_trim(unlist(strsplit(summary_of_list$Ssciname[l], "[|]"))), "[ ]+"))
colnames(multiple_sbj) <- c("genus","species",rep("sub.sp",ncol(multiple_sbj)-2))
multiple_sbj <- multiple_sbj[!duplicated(paste(multiple_sbj$genus,multiple_sbj$species)),]
multiple_sbj <- multiple_sbj[,1:2]
multiple_sbj$comb_name <- rowpaste(multiple_sbj)
multiple_sbj$pident_max <- NA
if (prod(allduplicates(multiple_sbj$genus))==1) { #If multiple subjects are the same genus
chsl <- multiple_sbj$comb_name
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,30),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm suggests to annotate to genus rank ::");cat("\n")
cat(c(paste(magic.pident(pr_df(paste0(unique(multiple_sbj$genus)," spp."),30),mean(summary_of_list$pident_max[l])),"::",
magic.pident(pr_df(mean(summary_of_list$pident_max[l]),5),mean(summary_of_list$pident_max[l])),
magic.pident(pr_df(mean(summary_of_list$pident[l]),5),mean(summary_of_list$pident[l])))),sep = "\n")
sl_0 <- paste0(paste(unique(multiple_sbj$genus))," spp.",collapse = " | ")
sl <- paste(sl_0," || ", paste(multiple_sbj$comb_name,collapse = " | "))
input$annotated_tax[input$qseqid==i] <- sl
for (ii in length(multiple_sbj$comb_name)) {multiple_sbj$pident_max <- summary_of_list$pident_max[min(grep(multiple_sbj$comb_name[ii],summary_of_list$Ssciname))]}
input$pmatchsel[input$qseqid==i] <- paste(round((multiple_sbj$pident_max/100),3),collapse = " | ")
} #If multiple subjects are the same genus
else if (prod(allduplicates(multiple_sbj$genus))==0) {#If multiple subjects are not the same genus
cat("\n");questions("A summary of subjects that your query has been blasted towards ::");cat("\n")
cat(c(paste(magic.pident(pr_df(summary_of_list$Ssciname,40),summary_of_list$pident_max),"::",
magic.pident(pr_df(summary_of_list$pident_max,5),summary_of_list$pident_max),
magic.pident(pr_df(summary_of_list$pident,5),summary_of_list$pident))),sep="\n");cat("\n")
cat("\n");questions("The algorithm suggests to annotate to all subjects with 100% match ::");cat("\n")
sl <- paste(unique(paste(multiple_sbj$genus,multiple_sbj$species)),collapse = " | ")
input$annotated_tax[input$qseqid==i] <- sl
input$pmatchsel[input$qseqid==i] <- paste(round((summary_of_list$pident_max[summary_of_list$Ssciname%in%str_trim(unlist(strsplit(sl, "[|]")))]/100),3),collapse = " | ")
}#If multiple subjects are not the same genus
}#If multiple subjects are 100%
#Esthetics
setTxtProgressBar(pb,j);cat("\n") #progress bar
j <- j+1 #loop mechanism
write.csv(input,"manually_annotated_function_outcome.csv",row.names = F)
} #Not skipping method 3
} #Loop of method 3
dim(input)
ret_df <- setNames(data.frame(matrix(NA,length(unique(input$qseqid)),3)),c("qseqid","ssciname","pident"))
ret_df
ret_df$qseqid <- c(unique(input$qseqid))
ret_df
ii
for (ii in unique(input$qseqid)) {
ret_df[ret_df==ii,2] <- unique(input$annotated_tax[input$qseqid==ii])
ret_df[ret_df==ii,3] <- unique(input$pmatchsel[input$qseqid==ii])
}
input$annotated_tax
unique(input$qseqid)
unique(input$qseqid)[3]
ii <- unique(input$qseqid)[3]
unique(input$annotated_tax[input$qseqid==ii])
unique(input$pmatchsel[input$qseqid==ii])
ret_df[ret_df==ii,2]
ret_df==ii
ret_df <- setNames(data.frame(matrix(NA,length(unique(input$qseqid)),3)),c("qseqid","ssciname","pident"))
ret_df$qseqid <- c(unique(input$qseqid))
for (ii in unique(input$qseqid)) {
ret_df[ret_df$qseqid==ii,2] <- unique(input$annotated_tax[input$qseqid==ii])
ret_df[ret_df$qseqid==ii,3] <- unique(input$pmatchsel[input$qseqid==ii])
}
ret_df
View(ret_df)
source("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Data/Rscripts/Manually_annotate.R") #Curate the metadata
manually_annotate(stoeckle_blast_output,method = 3)
library("devtools")
library(roxygen2)
#Set working directory
setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("./gled.functions")
document()
document()
setwd("..")
# create("gled.functions") #if you want to create a new pckg
setwd("./gled.functions")
document()
document()
document()
setwd("..")
install("gled.functions")
library(gled.functions)
writeLines(ls("package:gled.functions"))
#Set working directory
setwd("/Users/a36142/Documents/GitHub/ggednasd")
# create("gled.functions") #if you want to create a new pckg
setwd("./gled.functions")
document()
#Set working directory
setwd("/Users/a36142/Documents/GitHub/ggednasd")
# create("gled.functions") #if you want to create a new pckg
setwd("./gled.functions")
create("gled.functions") #if you want to create a new pckg
setwd("./gled.functions")
document()
setwd("..")
setwd("~/OneDrive - Havforskningsinstituttet/IMR/Rpackage")
getwd()
#Instal libraries
install.packages("devtools")
install.packages("devtools")
library("devtools")
devtools::install_github("klutometis/roxygen")
getwd()
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
create("ggu.base.fun") #if you want to create a new pckg
setwd("./ggu.base.fun")
document()
?document
document(../ggu.R)
document("../ggu.R")
setwd("./ggu.base.fun")
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
setwd("./ggu.base.fun")
document("")
document(R)
document()
pkgload::dev_help('rowpaste')
??@name
pkgload::dev_help('manually_annotate')
document("")
rlang::last_error()
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
setwd("./ggu.base.fun")
document()
rlang::last_error()
rlang::last_trace()
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
create("ggu.base.fun") #if you want to create a new pckg
setwd("./ggu.base.fun")
document()
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
setwd("./ggu.base.fun")
document()
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
setwd("./ggu.base.fun")
document()
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
setwd("./ggu.base.fun")
document()
pkgload::dev_help('motudiv')
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
setwd("./ggu.base.fun")
document()
pkgload::dev_help('manually_annotate')
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
setwd("./ggu.base.fun")
document()
pkgload::dev_help('manually_annotate')
setwd("..")
install("ggu.base.fun")
library(ggu.base.fun)
writeLines(ls("package:gled.functions"))
#Instal libraries
install.packages("devtools")
library("devtools")
install.packages("devtools")
library(roxygen2)
install.packages("devtools")
install.packages("devtools")
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
setwd("./ggu.base.fun")
document()
library(roxygen2)
devtools::install_github("klutometis/roxygen")
library(roxygen2)
#Set working directory
# setwd("/Users/a36142/Documents/GitHub/ggednasd")
setwd("/Users/a36142/Library/CloudStorage/OneDrive-Havforskningsinstituttet/IMR/Rpackage")
setwd("./ggu.base.fun")
document()
roxygen2::document()
??roxygen2::document()
?roxygen2::document()
